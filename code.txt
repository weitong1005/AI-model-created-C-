"
AI3700/
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ code.txt
â”œâ”€â”€ data
â”‚Â Â  â””â”€â”€ hanzi.txt
â”œâ”€â”€ main.cpp
â”œâ”€â”€ model
â””â”€â”€ src
    â”œâ”€â”€ file_utils.cpp
    â”œâ”€â”€ file_utils.h
    â”œâ”€â”€ hanzi_encoder.cpp
    â”œâ”€â”€ hanzi_encoder.h
    â”œâ”€â”€ matrix.cpp
    â”œâ”€â”€ matrix.h
    â”œâ”€â”€ rnn_model.cpp
    â”œâ”€â”€ rnn_model.h
    â”œâ”€â”€ start_model.cpp
    â””â”€â”€ start_model.h
"
data/hanzi.txt
"
a: é˜¿å•Šå“å“€å”‰åŸƒæŒ¨ç™ŒçŸ®è”¼çˆ±ç¢å®‰å²¸æŒ‰æ¡ˆæš—æ˜‚å‡¹ç†¬å‚²å¥¥æ¾³è…Œå–é”•å—„
ba: å…«å·´æ‰’å§ç–¤æ‹”è·‹æŠŠåçˆ¸ç½¢éœ¸æ°ç™½ç™¾æŸæ‘†è´¥æ‹œæ–‘ç­æ¬æ¿ç‰ˆåŠåŠä¼´æ‰®ç“£é‚¦å¸®è†€å‚æ£’åŒ…èƒé›¹å®é¥±ä¿å ¡æŠ¥æŠ±æš´çˆ†æ¯æ‚²ç¢‘åŒ—è´å¤‡èƒŒå€è¢«è¾ˆå¥”æœ¬ç¬¨å´©ç»·è¹¦é€¼é¼»æ¯”å½¼ç¬”é„™å¸å¿…æ¯•é—­åº‡æ¯™ç§˜å¼Šç¢§è”½å£é¿è‡‚è¾¹ç¼–é­æ‰ä¾¿å˜éè¾¨è¾©è¾«æ ‡å½ªè†˜è¡¨æ†‹åˆ«å®¾æ»¨å†°å…µä¸™æŸ„é¥¼å¹¶ç—…æ‹¨æ³¢ç»å‰¥è„–è ä¼¯é©³æ³Šåšæè†Šè–„åœè¡¥æ•ä¸å¸ƒæ­¥æ€–éƒ¨é­ƒç²‘ç¬†é’¯
cai: çŒœæ‰æè´¢è£é‡‡å½©ç¬è¸©èœå‚é¤æ®‹èš•æƒ­æƒ¨ç¿ä»“è‹èˆ±è—æ“ç³™æ§½è‰å†Œä¾§å•æµ‹ç­–å±‚æ›¾å‰æ’æŸ¥å¯ŸèŒ¬èŒ¶æ½å·®æ‹†æŸ´è±ºæ€æºé¦‹ç¼ è‰äº§é“²é˜é¢¤æ˜Œé•¿è‚ å°å¸¸å¿å‚åœºæ•ç•…å€¡å”±æŠ„é’è¶…å·¢æœå˜²æ½®åµç‚’è½¦æ‰¯å½»æ’¤å°˜è‡£æ²‰è¾°é™ˆæ™¨é—¯è¡¬ç§°è¶æ’‘æˆå‘ˆè¯šæ‰¿åŸä¹˜æƒ©ç¨‹æ¾„æ©™é€ç§¤åƒç—´æŒæ± è¿Ÿé©°è€»é½¿æ–¥èµ¤ç¿…å……å†²è™«å´‡å® æŠ½ä»‡ç»¸æ„ç¨ ç­¹é…¬ä¸‘è‡­å‡ºåˆé™¤å¨é”„ç¡€å‚¨æ¥šå¤„è§¦å·ç©¿ä¼ èˆ¹å–˜ä¸²ç–®çª—åºŠåˆ›å¹ç‚Šå‚é”¤æ˜¥çº¯å”‡æ·³é†‡è ¢æˆ³ç»°è¯ç¥ æ…ˆè¾ç£é›Œæ­¤æ¬¡åˆºèµåŒ†è‘±èªä»ä¸›å‡‘ç²—ä¿ƒé†‹ç°‡çªœç¯¡å‚¬æ‘§è„†ç²¹ç¿ æ‘å­˜å¯¸æ“æªé”™å²éª–ç²²
da: æ­è¾¾ç­”æ‰“å¤§å‘†æ­¹ä»£å¸¦å¾…æ€ è´·è¢‹é€®æˆ´ä¸¹å•æ‹…è€½èƒ†æ—¦ä½†è¯å¼¹æ·¡è›‹å½“æŒ¡å…šè¡æ¡£åˆ€å¨å¯¼å²›å€’è¹ˆåˆ°æ‚¼ç›—é“ç¨»å¾—å¾·çš„ç¯ç™»ç­‰çªå‡³ä½å ¤æ»´è¿ªæ•Œç¬›åº•æŠµåœ°å¼Ÿå¸é€’ç¬¬é¢ å…¸ç‚¹ç”µä½ƒåº—å«æ·€æ®¿åˆå¼é›•åŠé’“è°ƒæ‰çˆ¹è·Œå è¶ä¸å®ç›¯é’‰é¡¶è®¢å®šä¸¢ä¸œå†¬è‘£æ‡‚åŠ¨å†»æ ‹æ´éƒ½å…œæŠ–æ–—é™¡è±†é€—éƒ½ç£æ¯’è¯»ç‹¬å µèµŒæœè‚šåº¦æ¸¡ç«¯çŸ­æ®µæ–­ç¼ç……é”»å †é˜Ÿå¯¹å…‘å¨æ•¦è¹²ç›¾é¡¿å¤šå¤ºæœµèº²è€·å“’å—’é‘
e: ä¿„é¹…é¢æ¶é¥¿éæ©å„¿è€Œå°”è€³äºŒè´°å©€è½­è¿©
fa: å‘ä¹ä¼ç½šé˜€ç­æ³•å¸†ç•ªç¿»å‡¡çƒ¦ç¹åè¿”çŠ¯é¥­æ³›èŒƒè´©æ–¹åŠèŠ³é˜²å¦¨æˆ¿ä»¿è®¿çººæ”¾é£éå•¡è‚¥åŒªè¯½å è‚ºåºŸæ²¸è´¹åˆ†èŠ¬å©çº·æ°›åŸç„šç²‰ä»½å¥‹æ„¤ç²ªä¸°é£å°ç–¯å³°é”‹èœ‚é€¢ç¼è®½å‡¤å¥‰ä½›å¦å¤«æ•·è‚¤ä¼æ‰¶æ‹‚æœä¿˜æµ®ç¬¦å¹…ç¦æŠšç”«åºœæ–§ä¿¯è¾…è…çˆ¶ä»˜è´Ÿå¦‡é™„å’å¤èµ´å‰¯å‚…å¯Œè…¹è¦†ç 
ga: å°¬è¯¥æ”¹ç›–æ¦‚é’™å¹²ç”˜æ†è‚ç«¿ç§†èµ¶æ•¢æ„Ÿå¹²å†ˆåˆšçº²ç¼¸é’¢å²—æ¸¯æ é«˜è†ç¯™ç³•æç¨¿å‘Šå“¥æ­Œæå‰²é©è‘›æ ¼éš”ä¸ªå„ç»™æ ¹è·Ÿæ›´è€•å·¥å¼“å…¬åŠŸæ”»ä¾›å®«æ­èº¬å·©æ‹±å…±è´¡å‹¾æ²Ÿé’©ç‹—æ„è´­å¤Ÿä¼°å’•å­¤å§‘å¤è°·è‚¡éª¨é¼“å›ºæ•…é¡¾é›‡ç“œåˆ®æŒ‚ä¹–æ‹æ€ªå…³è§‚å®˜å† æ£ºé¦†ç®¡è´¯æƒ¯çŒç½å…‰å¹¿å½’é¾Ÿè§„é—ºè½¨é¬¼æŸœè´µæ¡‚è·ªæ»šæ£å›½æœè¿‡å°•æ—®
ha: å“ˆå­©æµ·å®³é…£å«å‡½å¯’å–Šç½•æ±‰æ±—æ—±æ‚ç„Šæ†¾æ’¼è¡Œèˆªå··æ¯«è±ªå¥½å·æµ©è€—å‘µå–åˆä½•å’Œæ²³æ ¸è·ç›’è´ºé»‘å˜¿ç—•å¾ˆç‹ æ¨å“¼æ’æ¨ªè¡¡è½°å“„çƒ˜çº¢å®æ´ªè™¹é¸¿ä¾¯å–‰çŒ´å¼ååšå€™ä¹å‘¼å¿½ç‹èƒ¡å£¶æ¹–ç³Šè™äº’æˆ·æŠ¤èŠ±åå“—æ»‘çŒ¾åŒ–åˆ’ç”»è¯æ€€æ§åæ¬¢è¿˜ç¯ç¼“å¹»å”¤æ¢æ‚£ç„•ç–¾è±¢æ…Œçš‡é»„ç…Œæ™ƒè°ç°æŒ¥æ¢è¾‰å›æ¯æ‚”æ±‡ä¼šè®³ç»˜è´¿ç§½æƒ æ…§æ˜å©šæµ‘é­‚æ··è±æ´»ç«ä¼™æˆ–è´§è·ç¥¸æƒ‘é“ªæ°¦åŠ¾
ji: å‡»é¥¥åœ¾æœºè‚Œé¸¡è¿¹ç§¯åŸºç»©æ¿€åŠå‰çº§å³ææ€¥ç–¾é›†ç±å‡ å·±æŒ¤è„Šè®¡è®°çºªå¿ŒæŠ€é™…å‰‚å­£æ—¢æµç»§å¯„å¯‚åŠ å¤¹ä½³å®¶å˜‰ç”²é’¾ä»·é©¾æ¶å‡å«ç¨¼å¥¸å°–åšé—´è‚©è‰°å…¼ç›‘ç…æ‹£ä¿­æŸ¬æ¡æ£€å‡å‰ªç®€è§ä»¶å»ºå‰‘èè´±å¥èˆ°æ¸æº…é‰´é”®ç®­æ±Ÿå°†å§œæµ†åƒµç–†è®²å¥–åŒ é™é…±äº¤éƒŠæµ‡éª„å¨‡èƒ¶æ•™ç„¦åš¼è§’ç‹¡è„šæ…ç¼´å«è½¿è¾ƒè§‰é˜¶çš†æ¥æ­è¡—èŠ‚åŠ«æ°æ´ç»“æ·æˆªç«­å§è§£ä»‹æˆ’å±Šç•Œå€Ÿå·¾æ–¤ä»Šé‡‘æ´¥ç­‹ä»…ç´§é”¦è°¨å°½åŠ²è¿‘è¿›æ™‹æµ¸ç¦äº¬ç»èŒæƒŠæ™¶ç›ç²¾äº•é¢ˆæ™¯è­¦å‡€å¾„ç«ç«Ÿæ•¬å¢ƒé™é•œçº ç©¶ä¹ä¹…é…’æ—§æ•‘å°±èˆ…å±…æ‹˜é å±€èŠæ©˜ä¸¾çŸ©å¥å·¨æ‹’å…·å‰§æƒ§æ®è·é”¯èšæå·å€¦ç»¢å†³ç»è§‰æ˜åš¼å†›å›å‡èŒä¿Šå³»éªä¸Œä¹©å‰æå½éº‚
ka: å’–å¡å¼€æ©å‡¯æ…¨åˆŠå ªç çœ‹åº·æ…·ç³ æ‰›æŠ—ç‚•è€ƒçƒ¤é ç§‘æ£µé¢—å£³å’³å¯æ¸´å…‹åˆ»å®¢è¯¾è‚¯å¦æ³å‘ç©ºå­”ææ§æŠ å£æ‰£æ¯å“­è‹¦åº“è£¤é…·å¤¸è·¨æŒå—å¿«å®½æ¬¾åŒ¡ç­ç‹‚å†µçŸ¿æ¡†æ—·äºçª¥è‘µé­æ„§æºƒæ˜†å›°æ‹¬é˜”å’”ä½§èƒ©
la: åƒæ‹‰å•¦å–‡è…Šèœ¡è¾£æ¥è±èµ–è“æ æ‹¦ç¯®è§ˆæ‡’çƒ‚æ»¥éƒç‹¼å»Šæœ—æµªæåŠ³ç‰¢è€ä½¬å§¥æ¶ä¹å‹’é›·å’æ³ªç±»ç´¯å†·å˜æ¢¨ç¦»ç’ƒé»ç¤¼æé‡Œç†é²¤åŠ›å†å‰ç«‹ä¸½åˆ©åŠ±ä¾‹éš¶ä¿©è¿å¸˜æ€œè²è”å»‰è„¸ç»ƒç‚¼æ‹é“¾è‰¯å‡‰æ¢ç²®ä¸¤äº®è°…è¾†é‡è¾½ç–—èŠåƒšäº†æ–™åˆ—åŠ£çƒˆçŒè£‚é‚»æ—ä¸´æ·‹ç£·çµé“ƒé™µé›¶é¾„é¢†ä»¤å¦æºœåˆ˜ç•™æµç¡«æ¦´æŸ³å…­é¾™è‹éš†å„æ‹¢ç¬¼å¼„æ¥¼æ‚æ¼éœ²å¢èŠ¦ç‚‰é²é™†å½•é¹¿ç¢Œè·¯é©´æ—…å±¡å¾‹è™‘ç»¿æ»¤å‰Œé‚‹æ—¯
ma: å¦ˆéº»é©¬ç›ç èš‚éª‚å—åŸ‹ä¹°éº¦å–è¿ˆè„‰ç’æ»¡æ›¼æ…¢æ¼«å¿™èŠ’ç›²èŒ«çŒ«æ¯›çŸ›èŒ…èŒ‚å†’è´¸å¸½è²Œä¹ˆæ²¡çœ‰æ¢…åª’ç…¤éœ‰æ¯ç¾å¦¹é—¨é—·ä»¬èŒç›ŸçŒ›æ¢¦çœ¯å¼¥è¿·è°œç±³ç§˜è§…å¯†èœœçœ ç»µæ£‰å…å‹‰é¢è‹—æç„ç§’å¦™åº™ç­æ°‘æ•åæ˜é¸£å‘½è°¬æ‘¸æ¨¡è†œæ‘©ç£¨æŠ¹æœ«æ²¡è«å¢¨é»˜è°‹æŸæ¯äº©ç‰¡å§†æ‹‡æœ¨ç›®ç‰§å¢“å¹•æ…•æš®ç©†ç¥ƒçŠ¸æ©
na: æ‹¿å“ªé‚£çº³é’ ä¹ƒå¥¶è€ç”·å—éš¾å›ŠæŒ æ¼è„‘é—¹å‘¢å†…å«©èƒ½å¦®æ³¥ä½ æ‹Ÿé€†å¹´å¿µå¨˜é…¿é¸Ÿå°¿ææ‚¨å®å‡ç‰›æ‰­çº½å†œæµ“å¼„å¥´åŠªæ€’å¥³æš–è™æŒªè¯ºæºè‚­è¡²
ou: æ¬§é¸¥æ®´å¶è—•å‘•æ²¤è€¦æ€„ç“¯
pa: è¶´çˆ¬å¸•æ€•æ‹æ’ç‰Œæ´¾æ”€ç›˜åˆ¤å›ç›¼ä¹“åºæ—èƒ–æŠ›ç‚®è¢è·‘æ³¡å‘¸é™ªåŸ¹èµ”ä½©é…å–·ç›†ç °æŠ¨çƒ¹æœ‹æ£šè“¬ç¡¼é¹æ§ç¢°æ‰¹æŠ«åŠˆçš®ç–²åŒ¹ç—åƒ»å±è­¬ç‰‡åç¯‡éª—é£˜æ¼‚ç¥¨æ’‡æ‹¼è´«é¢‘å“è˜ä¹’å¹³è¯„å‡­è‹¹ç“¶èå¡æ³¼å©†è¿«ç ´é­„å‰–æ‰‘é“ºä»†è‘¡æœ´æ™®è°±ç€‘ç­¢
qi: ä¸ƒå¦»å‡„æˆšæœŸæ¬ºæ¼†é½å…¶å¥‡æ­§éª‘æ£‹æ——ä¹ä¼å²‚å¯èµ·æ°”è¿„å¼ƒæ±½å¥‘ç Œå™¨æ°æ´½åƒè¿ç‰µé“…è°¦ç­¾å‰é’±é’³æ½œæµ…é£æ¬ æ¬¾æªè…”å¼ºå¢™æŠ¢æ‚„æ•²é”¹æ¡¥ç§å·§åˆ‡èŒ„ä¸”çªƒäº²ä¾µèŠ¹ç´ç¦½å‹¤é’æ°¢è½»å€¾æ¸…æƒ…æ™´é¡·è¯·åº†ç©·ä¸˜ç§‹æ±‚çƒåŒºæ›²é©±å±ˆè¶‹æ¸ å–å¨¶å»è¶£åœˆæƒå…¨æ³‰æ‹³çŠ¬åŠåˆ¸ç¼ºå´é›€ç¡®é¹Šä¿Ÿæ±”ç¢›è‘º
ran: ç„¶ç‡ƒæŸ“åš·å£¤è®©é¥¶æ‰°ç»•æƒ¹çƒ­äººä»å¿è®¤ä»»æ‰”ä»æ—¥ç»’è£å®¹ç†”èå†—æŸ”æ‰è‚‰å¦‚å„’ä¹³è¾±å…¥è½¯é”ç‘æ¶¦è‹¥å¼±è‹’èšºé«¯
sa: æ’’æ´’è¨å¡èµ›ä¸‰æ•£æ¡‘å—“ä¸§æ”éªšæ‰«å«‚è‰²æ¶©æ£®åƒ§æ€æ²™çº±å‚»å•¥ç­›æ™’å±±åˆ è¡«é—ªé™•æ‰‡å–„ä¼¤å•†è£³æ™Œèµä¸Šå°šææ¢¢çƒ§ç¨å‹ºå°‘å“¨èˆŒè›‡èˆè®¾ç¤¾å°„æ¶‰æ‘„ç”³ä¼¸èº«æ·±ç¥å®¡å©¶è‚¾ç”šæ¸—æ…å‡ç”Ÿå£°æ€§ç‰²èƒœç»³çœåœ£ç››å‰©å°¸å¤±å¸ˆè¯—æ–½ç‹®æ¹¿åçŸ³æ—¶è¯†å®æ‹¾èš€é£Ÿå²ä½¿å§‹é©¶å£«æ°ä¸–ç¤ºå¸‚å¼ä¼¼äº‹åŠ¿ä¾é¥°è¯•è§†æŸ¿æ˜¯é€‚å®¤é€é‡Šæ”¶æ‰‹å®ˆé¦–å¯¿å—å…½å”®æˆç˜¦ä¹¦å”æ®Šæ¢³ç–èˆ’è¾“è”¬ç†Ÿæš‘å±é¼ æ•°æœ¯æŸè¿°æ ‘ç«–æ•åˆ·è¡°æ‘”ç”©å¸…æ “åŒéœœçˆ½è°æ°´ç¨ç¡é¡ºè¯´å¸ä¸ç§æ€æ–¯æ’•æ­»å››å¯ºä¼¼é¥²è‚†æ¾å®‹é€è¯µæœè‰˜è‹ä¿—è¯‰è‚ƒç´ é€Ÿå®¿å¡‘é…¸è’œç®—è™½éšå²ç¢ç©—å­™æŸç¬‹ç¼©æ‰€ç´¢é”å…æŒ²è„
ta: ä»–å®ƒå¥¹å¡Œå¡”è¸å°æŠ¬å¤ªæ€æ³°è´ªæ‘Šæ»©å›è°ˆç—°æ½­å¦å¹ç‚­æ¢å¹æ±¤å”å ‚å¡˜è†›ç³–å€˜èººè¶Ÿæ¶›ææ»”é€ƒæ¡ƒé™¶æ·˜è®¨å¥—ç‰¹è—¤è…¾ç–¼æ¢¯è¸¢å•¼æé¢˜è¹„ä½“æ›¿å¤©æ·»ç”°ç”œå¡«æŒ‘æ¡è·³è´´é“å…å¬çƒƒå»·äº­åº­åœæŒºè‰‡é€šåŒé“œç«¥ç»Ÿç—›å·å¤´æŠ•é€å‡¸ç§ƒçªå›¾å¾’é€”æ¶‚å± åœŸåå…”å›¢æ¨è…¿é€€åå±¯æ‰˜æ‹–è„±é©¼å¦¥æ‹“å”¾æº»ç­é³
wa: æŒ–å“‡è›™å¨ƒç“¦æ­ªå¤–å¼¯æ¹¾ä¸¸å®Œç©é¡½æŒ½æ™šç¢—ä¸‡æ±ªäº¡ç‹ç½‘å¾€å¿˜æ—ºæœ›å±å¨å¾®ä¸ºå›´è¿å”¯ç»´ä¼ŸéŸ¦ä¼ªå°¾çº¬å§”èå«æœªä½å‘³ç•èƒƒå–‚æ…°æ¸©æ–‡çº¹é—»èšŠç¨³é—®ç¿å—¡çªæˆ‘æ²ƒå§æ¡ä¹Œæ±¡å±‹æ— å´å¾äº”åˆä¼æ­¦ä¾®èˆåŠ¡ç‰©è¯¯æ‚Ÿé›¾è…½å¨²ç•–
xi: å¤•è¥¿å¸å¸Œæ˜”ææ¯ç‰ºæ‚‰æƒœç¨€æºªé”¡ç†„ç†™èœ¥å˜»è†ä¹ å¸­è¢­åª³æ´—å–œæˆç³»ç»†éš™è™¾çå³¡ç‹­éœä¸‹å¤å“ä»™å…ˆçº¤æ€é²œé—²å¼¦å’¸è¡”å«Œæ˜¾é™©å¿ç°é™çº¿å®ªé™·é¦…ç¾¡çŒ®ä¹¡ç›¸é¦™å¢æ¹˜ç®±è¯¦ç¥¥ç¿”äº«å“æƒ³å‘å··é¡¹è±¡åƒæ©¡å‰Šæ¶ˆå®µè§é”€å°æ™“å­æ ¡ç¬‘æ•ˆäº›æ­‡åé‚ªèƒæ–œè°æºé‹å†™æ³„æ³»å¸å±‘æ¢°è°¢å¿ƒè¾›æ¬£æ–°è–ªä¿¡å…´æ˜Ÿè…¥åˆ‘è¡Œå½¢å‹é†’æå§“å¹¸æ€§å…„å‡¶èƒ¸åŒˆé›„ç†Šä¼‘ä¿®ç¾æœ½ç§€ç»£è¢–é¡»è™šéœ€å¾è®¸åºå™ç•œç»ªç»­é…—è“„å®£æ‚¬æ—‹ç„é€‰ç©´å­¦é›ªè¡€å‹‹å¯»å·¡è¯¢å¾ªè®­è®¯è¿…è‘¸èˆ„ç¦Š
ya: å‹æŠ¼é¸¦é¸­ç‰™èŠ½å´–å“‘äºšè®¶å’½çƒŸæ·¹å»¶ä¸¥è¨€å²©æ²¿ç‚ç ”ç›é¢œæªè¡æ©çœ¼æ¼”åŒå®´è‰³éªŒç„°é›ç‡•å¤®æ®ƒç§§æ‰¬ç¾Šé˜³æ¨æ´‹ä»°å…»æ°§ç—’æ ·è…°é‚€æ‘‡é¥å’¬è¯è¦è€€çˆ·ä¹Ÿå†¶é‡ä¸šå¶é¡µå¤œæ¶²ä¸€ä¼Šè¡£åŒ»ä¾ä»ªå¤·å®œå§¨ç§»é—ç–‘ä¹™å·²ä»¥çŸ£èšå€šæ¤…ä¹‰äº¿å¿†è‰ºè®®äº¦å¼‚å½¹æŠ‘è¯‘æ˜“ç–«ç›Šè°Šæ„æº¢æ¯…ç¿¼å› é˜´éŸ³å§»é“¶å¼•é¥®éšå°åº”è‹±å©´æ¨±é¹°è¿ç›ˆè¥è‡èµ¢å½±æ˜ ç¡¬å“Ÿæ‹¥ä½£æ°¸å’æ³³å‹‡ç”¨ä¼˜å¿§å¹½æ‚ å°¤ç”±é‚®çŠ¹æ²¹æ¸¸å‹æœ‰åˆå³å¹¼è¯±äºäºˆä½™é±¼å¨±æ¸”æ„‰æ„šä¸å®‡ç¾½é›¨è¯­ç‰è‚²éƒç‹±æµ´é¢„åŸŸæ¬²é‡å¾¡è£•æ„ˆèª‰å†¤å…ƒå‘˜å›­åŸåœ†æ´ç¼˜æºè¿œæ€¨é™¢æ„¿æ›°çº¦æœˆæ‚¦é˜…è·ƒè¶Šäº‘åŒ€å…è¿å­•èšœçšç—–
za: æ‚ç¾æ ½å®°è½½å†åœ¨å’±æ”’æš‚èµèµƒè„è‘¬é­ç³Ÿæ—©æ£æ¾¡è—»ç¶çš‚é€ å™ªç‡¥èºåˆ™æ‹©æ³½è´£è´¼æ€å¢èµ æ¸£æ‰è½§çœ¨ç‚¸æ‘˜å®…çª„å€ºæ²¾ç²˜å±•å æˆ˜ç«™å¼ ç« æ¶¨æŒä¸ˆä»—å¸èƒ€éšœæ‹›æ‰¾å¬å…†èµµç…§é®æŠ˜å“²è€…è¿™æµ™ççœŸè¯Šé˜µæŒ¯é•‡éœ‡äº‰å¾æŒ£çè’¸æ•´æ­£è¯éƒ‘æ”¿ç—‡ä¹‹æ”¯æ±èŠæçŸ¥è‚¢ç»‡è„‚èœ˜æ‰§ç›´å€¼èŒæ¤æ®–æ­¢åªæ—¨å€çº¸æŒ‡è¶¾è‡³å¿—åˆ¶å¸œæ²»è´¨ç§©è‡´æ™ºç½®ä¸­å¿ ç»ˆé’Ÿè‚¿ç§ä»²ä¼—é‡å·èˆŸå‘¨æ´²ç²¥è½´å®™æ˜¼çš±éª¤æœ±ç æ ªè¯¸çŒªè››ç«¹çƒ›é€ä¸»å±ç…®å˜±ä½åŠ©æ³¨è´®é©»æŸ±ç¥è‘—ç­‘æŠ“çˆªæ‹½ä¸“ç –è½¬èµšåº„è£…å£®çŠ¶æ’è¿½å‡†æ‰æ¡Œç€ä»”å…¹å§¿èµ„æ»‹ç±½å­ç´«å­—è‡ªå®—ç»¼æ£•è¸ªæ€»çºµèµ°å¥ç§Ÿè¶³æ—é˜»ç»„ç¥–é’»å˜´æœ€ç½ªé†‰å°Šéµæ˜¨å·¦ä½œååº§åšåŒæ‹¶å’‚

# è¡¥å……æ±‰å­—ä»¥æ»¡è¶³3700ä¸ª
beng: å´©ç»·æ³µè¹¦è¿¸ç”­å˜£
...................................
"

CMakeLists.txt
"
cmake_minimum_required(VERSION 3.10)
project(AI3700)

set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# ç¡®ä¿ä¸­æ–‡æ­£å¸¸å¤„ç†
add_compile_options(-finput-charset=UTF-8)

include_directories(src)

add_executable(AI3700
        main.cpp
        src/hanzi_encoder.cpp
        src/file_utils.cpp
        src/matrix.cpp
        src/matrix.h
        src/rnn_model.cpp
        src/rnn_model.h
        src/start_model.cpp
        src/start_model.h
)

# è‡ªåŠ¨å¤åˆ¶ hanzi.txt åˆ°æ„å»ºç›®å½•
add_custom_command(
        TARGET AI3700 POST_BUILD
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
        ${CMAKE_SOURCE_DIR}/data/hanzi.txt
        $<TARGET_FILE_DIR:AI3700>
)

# é’ˆå¯¹ä¸åŒå¹³å°çš„ç‰¹å®šè®¾ç½®
if(WIN32)
    # Windows ç‰¹å®šè®¾ç½®
    target_compile_definitions(AI3700 PRIVATE _CRT_SECURE_NO_WARNINGS)
elseif(UNIX)
    # Linux ç‰¹å®šè®¾ç½®
    target_compile_options(AI3700 PRIVATE -Wall -Wextra)
endif()
"
file_utils.h
"
#ifndef AI3700_FILE_UTILS_H
#define AI3700_FILE_UTILS_H

#include "hanzi_encoder.h"
#include <string>

class FileUtils {
public:
    static bool generateDataFiles(const HanziEncoder& encoder,
                                  const std::string& dataFile = "hanzi_data.bin",
                                  const std::string& codeFile = "hanzi_codes.bin");

    static bool loadFromDataFiles(HanziEncoder& encoder,
                                  const std::string& dataFile = "hanzi_data.bin",
                                  const std::string& codeFile = "hanzi_codes.bin");
};

#endif
"
file_utils.cpp
"
#include "file_utils.h"
#include <fstream>

bool FileUtils::generateDataFiles(const HanziEncoder& encoder,
                                  const std::string& dataFile,
                                  const std::string& codeFile) {
    // ç”Ÿæˆæ•°æ®æ–‡ä»¶
    std::ofstream dataOut(dataFile, std::ios::binary);
    if (!dataOut) return false;

    int count = encoder.size();
    dataOut.write(reinterpret_cast<const char*>(&count), sizeof(count));

    for (int i = 0; i < count; ++i) {
        std::string hanzi = encoder.decode(i);
        int len = hanzi.size();
        dataOut.write(reinterpret_cast<const char*>(&len), sizeof(len));
        dataOut.write(hanzi.data(), len);
    }
    dataOut.close();

    // ç”Ÿæˆç¼–ç æ–‡ä»¶
    std::ofstream codeOut(codeFile, std::ios::binary);
    if (!codeOut) return false;

    codeOut.write(reinterpret_cast<const char*>(&count), sizeof(count));
    for (int i = 0; i < count; ++i) {
        std::string hanzi = encoder.decode(i);
        int len = hanzi.size();
        codeOut.write(reinterpret_cast<const char*>(&len), sizeof(len));
        codeOut.write(hanzi.data(), len);
        codeOut.write(reinterpret_cast<const char*>(&i), sizeof(i));
    }
    codeOut.close();

    return true;
}

// loadFromDataFiles å®ç°ä¿æŒä¸å˜
"
hanzi_encoder.cpp
"
#include "hanzi_encoder.h"
#include <fstream>
#include <iostream>
#include <cctype>
#include <algorithm>

void HanziEncoder::clear() {
    hanziToId.clear();
    idToHanzi.clear();
}

bool HanziEncoder::loadFromFile(const std::string& filename) {
    clear();
    std::ifstream infile(filename);
    if (!infile) {
        std::cerr << "æ— æ³•æ‰“å¼€æ–‡ä»¶: " << filename << std::endl;
        return false;
    }

    std::string line;
    int totalAdded = 0;
    int lineNumber = 0;

    while (std::getline(infile, line)) {
        lineNumber++;
        if (line.empty()) continue;

        // æå–æ±‰å­—éƒ¨åˆ†ï¼ˆè·³è¿‡æ‹¼éŸ³ï¼‰
        size_t pos = line.find(':');
        if (pos == std::string::npos) continue;

        std::string hanziBlock = line.substr(pos + 1);

        // ç§»é™¤æ‰€æœ‰ç©ºæ ¼å’Œæ˜Ÿå·
        hanziBlock.erase(std::remove_if(hanziBlock.begin(), hanziBlock.end(),
                                        [](char c) { return std::isspace(static_cast<unsigned char>(c)) || c == '*'; }),
                         hanziBlock.end());

        // å¤„ç†è¿ç»­UTF-8å­—ç¬¦
        for (size_t i = 0; i < hanziBlock.size();) {
            int len = 0;
            unsigned char c = static_cast<unsigned char>(hanziBlock[i]);

            if (c < 0x80) {
                len = 1;  // ASCIIå­—ç¬¦
            } else if ((c & 0xE0) == 0xC0) {
                len = 2;  // 2å­—èŠ‚UTF-8
            } else if ((c & 0xF0) == 0xE0) {
                len = 3;  // 3å­—èŠ‚UTF-8ï¼ˆå¤§å¤šæ•°æ±‰å­—ï¼‰
            } else if ((c & 0xF8) == 0xF0) {
                len = 4;  // 4å­—èŠ‚UTF-8
            } else {
                i++;  // è·³è¿‡æ— æ•ˆå­—èŠ‚
                continue;
            }

            if (i + len > hanziBlock.size()) break;

            std::string hanzi = hanziBlock.substr(i, len);
            i += len;

            // æ·»åŠ åˆ°ç¼–ç å™¨
            if (hanziToId.find(hanzi) == hanziToId.end()) {
                hanziToId[hanzi] = idToHanzi.size();
                idToHanzi.push_back(hanzi);
                totalAdded++;
            }
        }
    }

    std::cout << "æˆåŠŸåŠ è½½ " << totalAdded << " ä¸ªæ±‰å­—\n";
    return true;
}

int HanziEncoder::encode(const std::string& hanzi) const {
    auto it = hanziToId.find(hanzi);
    return (it != hanziToId.end()) ? it->second : -1;
}

std::string HanziEncoder::decode(int code) const {
    return (code >= 0 && code < static_cast<int>(idToHanzi.size())) ? idToHanzi[code] : "";
}

int HanziEncoder::size() const {
    return static_cast<int>(idToHanzi.size());
}
"
hanzi_encoder.h
"
#ifndef AI3700_HANZI_ENCODER_H
#define AI3700_HANZI_ENCODER_H

#include <string>
#include <unordered_map>
#include <vector>

class HanziEncoder {
public:
    bool loadFromFile(const std::string& filename);
    int encode(const std::string& hanzi) const;
    std::string decode(int code) const;
    int size() const;
    void clear();

private:
    std::unordered_map<std::string, int> hanziToId;
    std::vector<std::string> idToHanzi;
};

#endif
"
matrix.cpp
"
//
// Created by bm on 25-7-23.
//
#include "matrix.h"
#include <cstdlib>
#include <cmath>

Matrix::Matrix(int rows, int cols, bool random) : rows(rows), cols(cols) {
    data.resize(rows, std::vector<double>(cols, 0.0));
    if (random) randomize();
}

Matrix::Matrix(const std::vector<std::vector<double>>& initData)
        : data(initData), rows(initData.size()), cols(initData[0].size()) {}

Matrix Matrix::operator+(const Matrix& other) const {
    if (rows != other.rows || cols != other.cols) {
        std::cerr << "çŸ©é˜µåŠ æ³•ç»´åº¦ä¸åŒ¹é…\n";
        return Matrix();
    }
    Matrix result(rows, cols);
    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            result.data[i][j] = data[i][j] + other.data[i][j];
    return result;
}

Matrix Matrix::operator-(const Matrix& other) const {
    if (rows != other.rows || cols != other.cols) {
        std::cerr << "çŸ©é˜µå‡æ³•ç»´åº¦ä¸åŒ¹é…\n";
        return Matrix();
    }
    Matrix result(rows, cols);
    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            result.data[i][j] = data[i][j] - other.data[i][j];
    return result;
}

Matrix Matrix::operator*(const Matrix& other) const {
    // ä¸¥æ ¼æ£€æŸ¥ç»´åº¦åŒ¹é…
    if (cols != other.rows) {
        std::cerr << "è‡´å‘½é”™è¯¯ï¼šçŸ©é˜µä¹˜æ³•ç»´åº¦ä¸åŒ¹é… (" << rows << "x" << cols
                  << ") * (" << other.rows << "x" << other.cols << ")\n";
        std::exit(1); // ç›´æ¥é€€å‡ºï¼Œé¿å…åç»­é”™è¯¯
    }
    Matrix result(rows, other.cols);
    for (int i = 0; i < rows; i++) {
        for (int k = 0; k < cols; k++) {
            if (data[i][k] == 0) continue;
            for (int j = 0; j < other.cols; j++) {
                result.data[i][j] += data[i][k] * other.data[k][j];
            }
        }
    }
    return result;
}

Matrix Matrix::operator*(double scalar) const {
    Matrix result(rows, cols);
    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            result.data[i][j] = data[i][j] * scalar;
    return result;
}

Matrix Matrix::transpose() const {
    Matrix result(cols, rows);
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            result.data[j][i] = data[i][j];
        }
    }
//     è°ƒè¯•ï¼šéªŒè¯è½¬ç½®åçš„ç»´åº¦
     std::cout << "è½¬ç½®å‰: " << rows << "x" << cols
               << " â†’ è½¬ç½®å: " << result.rows << "x" << result.cols << "\n";
    return result;
}

Matrix Matrix::sigmoid(const Matrix& m) {
    Matrix result(m.rows, m.cols);
    for (int i = 0; i < m.rows; i++)
        for (int j = 0; j < m.cols; j++)
            result.data[i][j] = 1.0 / (1.0 + exp(-m.data[i][j]));
    return result;
}

Matrix Matrix::tanh(const Matrix& m) {
    Matrix result(m.rows, m.cols);
    for (int i = 0; i < m.rows; i++)
        for (int j = 0; j < m.cols; j++)
            result.data[i][j] = std::tanh(m.data[i][j]);
    return result;
}

Matrix Matrix::tanhDerivative(const Matrix& m) {
    Matrix result(m.rows, m.cols);
    for (int i = 0; i < m.rows; i++)
        for (int j = 0; j < m.cols; j++) {
            double t = std::tanh(m.data[i][j]);
            result.data[i][j] = 1 - t * t;
        }
    return result;
}

void Matrix::randomize(double min, double max) {
    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            data[i][j] = min + (max - min) * ((double)rand() / RAND_MAX);
}
"
matrix.h
"
//
// Created by bm on 25-7-23.
//

#ifndef AI3700_MATRIX_H
#define AI3700_MATRIX_H

#include <vector>
#include <iostream>

class Matrix {
public:
    std::vector<std::vector<double>> data;
    int rows;
    int cols;

    Matrix() : rows(0), cols(0) {}
    Matrix(int rows, int cols, bool random = false);
    Matrix(const std::vector<std::vector<double>>& initData);

    Matrix operator+(const Matrix& other) const;
    Matrix operator-(const Matrix& other) const;
    Matrix operator*(const Matrix& other) const;
    Matrix operator*(double scalar) const;
    Matrix transpose() const;

    static Matrix sigmoid(const Matrix& m);
    static Matrix tanh(const Matrix& m);
    static Matrix tanhDerivative(const Matrix& m);

    void randomize(double min = -0.5, double max = 0.5);
};


#endif //AI3700_MATRIX_H
"
rnn_model.cpp
"
//
// Created by bm on 25-7-23.
//
#include "rnn_model.h"
#include <fstream>
#include <cmath>
#include <iostream>

RNNModel::RNNModel(int vocabSize, int hiddenSize, int layers)
        : vocabSize(vocabSize), hiddenSize(hiddenSize), layers(layers) {
    // åˆå§‹åŒ–æƒé‡çŸ©é˜µï¼ˆç¡®ä¿ç»´åº¦æ­£ç¡®ï¼‰
    Wxh = Matrix(hiddenSize, vocabSize, true);  // è¾“å…¥â†’éšè—: [h x v]
    Whh.resize(layers, Matrix(hiddenSize, hiddenSize, true));  // éšè—â†’éšè—: [h x h]
    Why = Matrix(vocabSize, hiddenSize, true);  // éšè—â†’è¾“å‡º: [v x h]
    bh.resize(layers, Matrix(hiddenSize, 1, true));  // éšè—å±‚åç½®: [h x 1]
    by = Matrix(vocabSize, 1, true);  // è¾“å‡ºå±‚åç½®: [v x 1]
}

RNNModel::ForwardCache RNNModel::forward(const std::vector<int>& inputs) {
    ForwardCache cache(layers, hiddenSize, vocabSize);

    for (size_t t = 0; t < inputs.size(); t++) {
        // è¾“å…¥å±‚ç‹¬çƒ­ç¼–ç  [v x 1]
        int idx = inputs[t];
        if (idx < 0 || idx >= vocabSize) {
            std::cerr << "æ— æ•ˆæ±‰å­—ç´¢å¼•: " << idx << "\n";
            std::exit(1);
        }
        Matrix x(vocabSize, 1);
        x.data[idx][0] = 1.0;

        // ç¬¬ä¸€å±‚è®¡ç®— [h x 1] = [h x v] * [v x 1] + [h x h] * [h x 1] + [h x 1]
        Matrix h1 = Wxh * x + Whh[0] * cache.h[0] + bh[0];
        cache.h[0] = Matrix::tanh(h1);

        // æ·±å±‚è®¡ç®—ï¼ˆä»…1å±‚æ—¶ä¸æ‰§è¡Œï¼‰
        for (int l = 1; l < layers; l++) {
            Matrix hl = Whh[l] * cache.h[l-1] + bh[l];
            cache.h[l] = Matrix::tanh(hl);
        }

        // è¾“å‡ºå±‚è®¡ç®— [v x 1] = [v x h] * [h x 1] + [v x 1]
        cache.y = Why * cache.h[layers-1] + by;
    }
    return cache;
}

void RNNModel::train(const std::vector<int>& sequence, double learningRate) {
    if (sequence.size() < 2) return;
    std::vector<int> inputs(sequence.begin(), sequence.end() - 1);
    std::vector<int> targets(sequence.begin() + 1, sequence.end());

    auto cache = forward(inputs);
    int lastTarget = targets.back();
    if (lastTarget < 0 || lastTarget >= vocabSize) return;

    // è¾“å‡ºè¯¯å·® [v x 1]
    Matrix dy(vocabSize, 1);
    for (int i = 0; i < vocabSize; i++) {
        dy.data[i][0] = cache.y.data[i][0] - (i == lastTarget ? 1.0 : 0.0);
    }

    // æœ€åä¸€å±‚éšè—å±‚è¯¯å·® [h x 1] = [h x v] * [v x 1]ï¼ˆWhyè½¬ç½®åæ˜¯[h x v]ï¼‰
    std::vector<Matrix> dh(layers);
    dh[layers-1] = Why.transpose() * dy;
    dh[layers-1] = dh[layers-1] * Matrix::tanhDerivative(cache.h[layers-1]);

    // æ·±å±‚è¯¯å·®åå‘ä¼ æ’­ï¼ˆä»…1å±‚æ—¶ä¸æ‰§è¡Œï¼‰
    for (int l = layers-2; l >= 0; l--) {
        dh[l] = Whh[l+1].transpose() * dh[l+1];
        dh[l] = dh[l] * Matrix::tanhDerivative(cache.h[l]);
    }

    // æ›´æ–°è¾“å‡ºå±‚æƒé‡ [v x h] = [v x h] - [v x 1] * [1 x h] * lr
    Matrix why_grad = dy * cache.h[layers-1].transpose();  // å…³é”®ä¿®å¤ï¼šä½¿ç”¨è½¬ç½®
    Why = Why - why_grad * learningRate;
    by = by - dy * learningRate;

    // æ›´æ–°ç¬¬ä¸€å±‚è¾“å…¥æƒé‡ [h x v] = [h x v] - [h x 1] * [1 x v] * lr
    int lastInput = inputs.back();
    Matrix x(vocabSize, 1);
    x.data[lastInput][0] = 1.0;
    Matrix wxh_grad = dh[0] * x.transpose();  // å…³é”®ä¿®å¤ï¼šä½¿ç”¨è½¬ç½®
    Wxh = Wxh - wxh_grad * learningRate;

    // æ›´æ–°éšè—å±‚æƒé‡ [h x h] = [h x h] - [h x 1] * [1 x h] * lr
    for (int l = 0; l < layers; l++) {
        Matrix h_prev = (l == 0) ? cache.h[0] : cache.h[l-1];
        Matrix whh_grad = dh[l] * h_prev.transpose();  // å…³é”®ä¿®å¤ï¼šä½¿ç”¨è½¬ç½®
        Whh[l] = Whh[l] - whh_grad * learningRate;
        bh[l] = bh[l] - dh[l] * learningRate;
    }
}

int RNNModel::predict(const std::vector<int>& inputSeq, bool random) {
    auto cache = forward(inputSeq);
    if (random) {
        double sum = 0;
        for (int i = 0; i < vocabSize; i++)
            sum += exp(cache.y.data[i][0]);
        double r = (double)rand() / RAND_MAX;
        double accum = 0;
        for (int i = 0; i < vocabSize; i++) {
            accum += exp(cache.y.data[i][0]) / sum;
            if (accum >= r) return i;
        }
    }
    int maxIdx = 0;
    double maxVal = cache.y.data[0][0];
    for (int i = 1; i < vocabSize; i++) {
        if (cache.y.data[i][0] > maxVal) {
            maxVal = cache.y.data[i][0];
            maxIdx = i;
        }
    }
    return maxIdx;
}

void RNNModel::selfLearn(int iterations, int seqLen, double lr) {
    for (int i = 0; i < iterations; i++) {
        std::vector<int> seq;
        for (int j = 0; j < seqLen; j++)
            seq.push_back(rand() % vocabSize);
        train(seq, lr);
        if (i % 5000 == 0)
            printf("è¿­ä»£ %d/%d\n", i, iterations);
    }
}

bool RNNModel::save(const std::string& filename) {
    std::ofstream fout(filename, std::ios::binary);
    if (!fout) return false;

    fout.write((char*)&vocabSize, sizeof(vocabSize));
    fout.write((char*)&hiddenSize, sizeof(hiddenSize));
    fout.write((char*)&layers, sizeof(layers));

    auto saveMatrix = [&](const Matrix& m) {
        fout.write((char*)&m.rows, sizeof(m.rows));
        fout.write((char*)&m.cols, sizeof(m.cols));
        for (const auto& row : m.data)
            fout.write((char*)row.data(), row.size() * sizeof(double));
    };

    saveMatrix(Wxh);
    for (const auto& m : Whh) saveMatrix(m);
    saveMatrix(Why);
    for (const auto& m : bh) saveMatrix(m);
    saveMatrix(by);

    return true;
}

bool RNNModel::load(const std::string& filename) {
    std::ifstream fin(filename, std::ios::binary);
    if (!fin) return false;

    fin.read((char*)&vocabSize, sizeof(vocabSize));
    fin.read((char*)&hiddenSize, sizeof(hiddenSize));
    fin.read((char*)&layers, sizeof(layers));

    auto loadMatrix = [&](Matrix& m) {
        int rows, cols;
        fin.read((char*)&rows, sizeof(rows));
        fin.read((char*)&cols, sizeof(cols));
        m = Matrix(rows, cols);
        for (int i = 0; i < rows; i++) {
            m.data[i].resize(cols);
            fin.read((char*)m.data[i].data(), cols * sizeof(double));
        }
    };

    loadMatrix(Wxh);
    Whh.resize(layers);
    for (int i = 0; i < layers; i++) loadMatrix(Whh[i]);
    loadMatrix(Why);
    bh.resize(layers);
    for (int i = 0; i < layers; i++) loadMatrix(bh[i]);
    loadMatrix(by);

    return true;
}
"
rnn_model.h
"
//
// Created by bm on 25-7-23.
//

#ifndef AI3700_RNN_MODEL_H
#define AI3700_RNN_MODEL_H

#include "matrix.h"
#include <vector>
#include <string>

class RNNModel {
public:
    RNNModel(int vocabSize, int hiddenSize, int layers = 2);

    void train(const std::vector<int>& sequence, double learningRate);
    int predict(const std::vector<int>& inputSeq, bool random = false);
    bool save(const std::string& filename);
    bool load(const std::string& filename);
    void selfLearn(int iterations, int seqLen, double lr);

private:
    int vocabSize;  // æ±‰å­—æ€»æ•°
    int hiddenSize; // éšè—å±‚å¤§å°
    int layers;     // å±‚æ•°

    // æƒé‡çŸ©é˜µå®šä¹‰ï¼š
    // - ä»…ç¬¬ä¸€å±‚ä½¿ç”¨Wxhï¼ˆè¾“å…¥â†’éšè—ï¼‰
    // - æ‰€æœ‰å±‚éƒ½ä½¿ç”¨Whhï¼ˆéšè—â†’éšè—ï¼‰
    Matrix Wxh;       // ç¬¬ä¸€å±‚ï¼šè¾“å…¥â†’éšè— [hiddenSize x vocabSize]
    std::vector<Matrix> Whh;  // æ‰€æœ‰å±‚ï¼šéšè—â†’éšè— [hiddenSize x hiddenSize]
    Matrix Why;       // è¾“å‡ºå±‚ï¼šéšè—â†’è¾“å‡º [vocabSize x hiddenSize]
    std::vector<Matrix> bh;   // æ‰€æœ‰å±‚ï¼šéšè—å±‚åç½® [hiddenSize x 1]
    Matrix by;        // è¾“å‡ºå±‚ï¼šåç½® [vocabSize x 1]

    struct ForwardCache {
        std::vector<Matrix> h;  // å„å±‚éšè—çŠ¶æ€ [hiddenSize x 1]
        Matrix y;               // è¾“å‡º [vocabSize x 1]
        ForwardCache(int layers, int hiddenSize, int vocabSize) {
            h.resize(layers, Matrix(hiddenSize, 1));
            y = Matrix(vocabSize, 1);
        }
    };

    ForwardCache forward(const std::vector<int>& inputs);
};


#endif //AI3700_RNN_MODEL_H

"
start_model.cpp
"
//
// Created by bm on 25-7-23.
//

// start_model.cpp
#include "start_model.h"
#include <vector>
#include <string>

StartModel::StartModel(HanziEncoder& encoder, int hiddenSize, int layers)
        : encoder(encoder), model(encoder.size(), hiddenSize, layers) {}

bool StartModel::loadModel(const std::string& path) {
    return model.load(path);
}

bool StartModel::saveModel(const std::string& path) {
    return model.save(path);
}

void StartModel::train(int iterations, double lr) {
    model.selfLearn(iterations, 8, lr);  // çŸ­åºåˆ—è®­ç»ƒï¼Œé¿å…å†…å­˜å ç”¨è¿‡é«˜
}

// å­—ç¬¦ä¸²è½¬ç¼–ç åºåˆ—ï¼ˆå¤„ç†UTF-8ï¼‰
std::vector<int> StartModel::strToSeq(const std::string& input) {
    std::vector<int> seq;
    for (size_t i = 0; i < input.size();) {
        unsigned char c = (unsigned char)input[i];
        size_t len = 1;
        if ((c & 0xF0) == 0xE0) len = 3;  // æ±‰å­—ä¸º3å­—èŠ‚UTF-8
        else if ((c & 0xE0) == 0xC0) len = 2;
        else if (c >= 0x80) { i++; continue; }  // è·³è¿‡æ— æ•ˆå­—ç¬¦

        std::string hanzi = input.substr(i, len);
        i += len;
        int code = encoder.encode(hanzi);
        if (code != -1) seq.push_back(code);
    }
    return seq;
}

// ç¼–ç åºåˆ—è½¬å­—ç¬¦ä¸²
std::string StartModel::seqToStr(const std::vector<int>& seq) {
    std::string s;
    for (int code : seq) s += encoder.decode(code);
    return s;
}

// ç”Ÿæˆå›ç­”
std::string StartModel::generateResponse(const std::string& input, int length) {
    std::vector<int> inputSeq = strToSeq(input);
    if (inputSeq.empty()) return "æœªè¯†åˆ«åˆ°æœ‰æ•ˆæ±‰å­—";

    std::vector<int> outputSeq = inputSeq;
    for (int i = 0; i < length; i++) {
        // åŸºäºæœ€å3ä¸ªå­—ç¬¦é¢„æµ‹ï¼Œå¢å¼ºä¸Šä¸‹æ–‡å…³è”
        std::vector<int> context = outputSeq;
        if (context.size() > 3)
            context = std::vector<int>(context.end() - 3, context.end());
        int next = model.predict(context, true);
        outputSeq.push_back(next);
    }

    return seqToStr(outputSeq);
}
"
start_model.h
"
//
// Created by bm on 25-7-23.
//

#ifndef AI3700_START_MODEL_H
#define AI3700_START_MODEL_H

#include "rnn_model.h"
#include "hanzi_encoder.h"
#include <string>

class StartModel {
public:
    StartModel(HanziEncoder& encoder, int hiddenSize = 64, int layers = 2);
    bool loadModel(const std::string& path);
    bool saveModel(const std::string& path);
    void train(int iterations = 20000, double lr = 0.001);
    std::string generateResponse(const std::string& input, int length = 15);

private:
    HanziEncoder& encoder;
    RNNModel model;
    std::vector<int> strToSeq(const std::string& input);
    std::string seqToStr(const std::vector<int>& seq);
};

#endif //AI3700_START_MODEL_H
â€œ
main.cpp
"
#include "hanzi_encoder.h"
#include "file_utils.h"
#include "start_model.h"
#include <iostream>
#include <sys/stat.h>
#include <sys/types.h>  // ç”¨äºåˆ›å»ºç›®å½•

// åˆ›å»ºç›®å½•ï¼ˆæ”¯æŒå¤šçº§ç›®å½•ï¼‰
bool createDirectory(const std::string& path) {
#ifdef _WIN32
    return CreateDirectoryA(path.c_str(), NULL) != 0;
#else
    mode_t mode = 0755;
    return mkdir(path.c_str(), mode) == 0;
#endif
}

bool fileExists(const std::string& path) {
    struct stat buffer;
    return (stat(path.c_str(), &buffer) == 0);
}

int main() {
    HanziEncoder encoder;

    std::cout << "ğŸ“– åŠ è½½æ±‰å­—åº“...\n";
    if (!encoder.loadFromFile("hanzi.txt")) {
        std::cerr << "âŒ æ±‰å­—åº“åŠ è½½å¤±è´¥\n";
        return 1;
    }
    std::cout << "âœ… åŠ è½½ " << encoder.size() << " ä¸ªæ±‰å­—\n";

    // ç¡®ä¿æ¨¡å‹ç›®å½•å­˜åœ¨
    std::string modelDir = "model";
    if (!fileExists(modelDir)) {
        std::cout << "ğŸ“‚ åˆ›å»ºæ¨¡å‹ç›®å½•...\n";
        if (!createDirectory(modelDir)) {
            std::cerr << "âŒ æ— æ³•åˆ›å»ºæ¨¡å‹ç›®å½•: " << modelDir << "\n";
            return 1;
        }
    }

    StartModel model(encoder, 1, 4);
    std::string modelPath = modelDir + "/model.bin";

    if (!fileExists(modelPath)) {
        std::cout << "\nâ³ é¦–æ¬¡è¿è¡Œï¼Œå¼€å§‹è®­ç»ƒæ¨¡å‹...\n";
        model.train(5000, 0.001);

        std::cout << "ğŸ’¾ ä¿å­˜æ¨¡å‹...\n";
        if (!model.saveModel(modelPath)) {
            std::cerr << "âŒ æ¨¡å‹ä¿å­˜å¤±è´¥ï¼è¯·æ£€æŸ¥ç›®å½•æƒé™\n";
            // å°è¯•ä¿å­˜åˆ°å½“å‰ç›®å½•ä½œä¸ºå¤‡é€‰
            if (model.saveModel("model.bin")) {
                std::cout << "âš ï¸ å·²å¤‡é€‰ä¿å­˜åˆ°å½“å‰ç›®å½•: model.bin\n";
            } else {
                std::cerr << "âŒ æ‰€æœ‰ä¿å­˜è·¯å¾„å‡å¤±è´¥\n";
                return 1;
            }
        } else {
            std::cout << "âœ… æ¨¡å‹ä¿å­˜è‡³ " << modelPath << "\n";
        }
    } else {
        std::cout << "\nğŸ“‚ åŠ è½½å·²æœ‰æ¨¡å‹...\n";
        if (!model.loadModel(modelPath)) {
            std::cerr << "âŒ æ¨¡å‹åŠ è½½å¤±è´¥\n";
            return 1;
        }
    }

    std::cout << "\nğŸ’¬ æ¨¡å‹å°±ç»ªï¼Œè¾“å…¥qé€€å‡º\n";
    std::string input;
    while (true) {
        std::cout << "ä½ : ";
        std::getline(std::cin, input);
        if (input == "q") break;
        std::string response = model.generateResponse(input, 10);
        std::cout << "AI: " << response << "\n\n";
    }

    return 0;
}

"